# Documentation: The "Unknown Pleasure" Animation

This document provides a comprehensive overview of the design, mathematics, and implementation of the "Unknown Pleasure" audio-visual animation within the `when` project.

## 1. The Vision: Translating Art to Braille

The primary goal was to recreate the iconic, pseudo-3D waveform from the "Unknown Pleasures" album cover as a real-time, audio-responsive terminal animation. The key to achieving the desired high-fidelity look in a text-based environment was the use of **8-dot Braille characters**.

### Why Braille?

A standard terminal grid is very low-resolution. However, by treating each character cell not as a single entity but as a **2x4 grid of individual dots**, we can effectively increase the rendering resolution by a factor of 8. The `notcurses` library abstracts this concept, allowing us to "plot" pixels on this sub-cell grid, which it then composes into the correct Unicode Braille character (`U+2800` to `U+28FF`). This gives us the fine control needed to render smooth, sloped lines instead of blocky characters.

## 2. Architectural Integration

The animation is designed as a modular component that plugs directly into the event-driven architecture defined in `DESIGN.md`.

- **Inheritance**: The `PleasureAnimation` class inherits from the base `Animation` interface, fulfilling its contract (`init`, `update`, `render`, etc.).
- **Registration**: It is registered in the `AnimationManager`, which is responsible for its lifecycle.
- **Event-Driven Updates**: The animation subscribes to the `FrameUpdateEvent` via the `EventBus`. On each frame, the `update` method receives fresh audio FFT data, which it uses to drive the animation's state.
- **Configuration**: The animation's numerous parameters are loaded from the `when.toml` file, allowing for easy tuning without recompiling.

## 3. The Generative Model: A Sum of Gaussian Ridges

Early in the design process, we pivoted from a simple visualization of historical audio data to a more sophisticated **generative model**. Instead of directly plotting the FFT data, the animation *interprets* the audio's energy to drive a procedural system. This creates a more organic and aesthetically pleasing result.

### The Core Components:

1.  **Global Envelope**: The `update` method first calculates the overall energy of the low-frequency audio bands and tracks it in a smoothed `global_magnitude_` variable. This acts as a master "volume knob" for the animation's intensity.

2.  **The Ridge System**: The visual is composed of several "ridges" or peaks. Each ridge is an independent object (`RidgeState`) with its own position, magnitude, and movement characteristics. A random number of ridges are created for each line.

3.  **Organic Movement**: To avoid sterile, robotic movement, the ridges don't move directly. Instead:
    *   A `target_pos` and `target_magnitude` are defined for each ridge.
    *   Periodically (based on a randomized timer), these targets are "jittered" with a small random value. The `target_magnitude` is based on the `global_magnitude_`.
    *   The ridge's `current_pos` and `current_magnitude` are then smoothly interpolated towards these moving targets in every frame. This multi-layered smoothing is the key to the fluid, natural motion of the peaks.

4.  **The Mathematical Model: Gaussian Summation**: The final shape of each horizontal line (`line_profile_`) is generated by summing the influence of all its ridges at every point along its width. The influence of a single ridge is calculated using a **Gaussian (Normal Distribution) function**:

    ```
    // For each horizontal point x_norm (from 0.0 to 1.0):
    float ridge_sum = 0.0f;
    for (const auto& ridge : ridges) {
        float dx = x_norm - ridge.current_pos;
        float gaussian = exp(-(dx * dx) / (2.0f * sigma * sigma));
        ridge_sum += ridge.current_magnitude * gaussian;
    }
    ```

    This mathematical model is perfect for the desired aesthetic, as it naturally creates smooth, bell-shaped curves that overlap and blend beautifully.

## 4. The Occlusion Effect: A Z-Buffer in the Terminal

The most significant technical challenge was creating a convincing depth effect where nearer lines occlude farther ones. This was solved by implementing a classic computer graphics technique known as a **Z-buffer**, which we call the `skyline_buffer`.

### Implementation Details:

1.  **Pixel Grid**: The rendering logic operates on a high-resolution pixel grid (`rows * 4` by `cols * 2`), not on the character grid.

2.  **The `skyline_buffer`**: This is a `std::vector<int>` with a size equal to the number of *pixel columns* on the plane. At the start of each frame, it is initialized with a value representing the very bottom of the screen.

3.  **Front-to-Back Rendering**: It is critical that the lines are rendered in a strict front-to-back order. The main `render` loop iterates from `line_index = 0` (the nearest, bottom-most line) to the last line.

4.  **The Occlusion Check**: The line-drawing function (`draw_occluded_line`) implements the core logic. For every single *dot* it intends to draw at pixel coordinate `(x, y)`, it first performs this check:

    ```cpp
    if (y < skyline_buffer[x]) {
        // 1. This pixel is VISIBLE.
        // Update the skyline to this new, higher position.
        skyline_buffer[x] = y;

        // 2. Set the Braille dot in our off-screen buffer.
        set_braille_pixel(cells, ...);
    }
    // else: The pixel is occluded by a nearer line, so do nothing.
    ```

    Because we render front-to-back, any pixel that is already "filled" in the `skyline_buffer` must have been drawn by a nearer line. By only drawing pixels that are "higher" (a smaller `y` value) than the current skyline value, we achieve a perfect and efficient occlusion effect.

5.  **Two-Pass Rendering**: To optimize performance, the implementation uses a two-pass approach. The first pass computes the entire scene by rasterizing all visible line segments into an in-memory `braille_cells` buffer. The second pass then "blits" this buffer to the screen, converting the bitmasks in the buffer into the final Unicode characters. This minimizes expensive calls to `notcurses` drawing functions.

## 5. Final Polish: Perspective

To further enhance the 3D effect, a simple perspective calculation was added. In the `update` loop, a `depth_scale` is calculated based on the line's index. This scalar is used to slightly reduce the magnitude and base level of farther lines, making them appear less prominent, as if they were receding into the distance.
