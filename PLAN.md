# Plan: Implementing the "Pleasure" Animation

This document outlines a detailed, step-by-step plan to implement the `PleasureAnimation`, which mimics the iconic "Unknown Pleasures" album art. The plan is designed to be incremental, with each step producing a verifiable result.

## Goal

To create a real-time, audio-responsive, multi-line visualization using Braille characters in `notcurses`, featuring a pseudo-3D occlusion effect where nearer lines block farther ones.

## Naming Conventions

As per the existing project structure, the implementation will adhere to the following naming conventions:

- **File Names**: `snake_case` (e.g., `pleasure_animation.h`).
- **Class/Struct Names**: `PascalCase` (e.g., `PleasureAnimation`).
- **Function/Method Names**: `snake_case` (e.g., `draw_occluded_line`).
- **Variables/Parameters**: `snake_case` (e.g., `skyline_buffer`).

## Prerequisite: Configuration

To ensure we can develop and test the `PleasureAnimation` in isolation, we will configure the application to load only this animation.

- **File to Edit**: `when.toml`
- **Action**: Modify the `scene.animation` key to ensure only the `pleasure` animation is active.

**Example `when.toml` setup:**

```toml
# when.toml

[scene]
animation = "pleasure" # This is the name we will register for the new animation
```

---

## Implementation Steps

### Step 1 & 2: Scaffolding & Basic Rendering (Completed)

- **Result**: A basic `PleasureAnimation` class has been created and integrated. It can render a static Braille line, confirming the `notcurses` setup.

### Step 3: Sloped Line Rasterization (Completed)

- **Result**: A robust, two-pass rendering system has been implemented. A `draw_line` function rasterizes a line onto an in-memory `braille_cells` buffer, which is then blitted to the screen. This is an efficient approach for composing Braille characters.

### Step 4: Generative Waveform Logic (Completed)

- **Goal**: Generate a dynamic, audio-reactive line profile that emulates the "Unknown Pleasures" aesthetic, replacing the simple history buffer.
- **Result**: A sophisticated generative model has been implemented:
  1.  **Ridge System**: The animation now simulates multiple "ridges" (peaks) using a `RidgeState` struct.
  2.  **Audio Reactivity**: The overall energy of the audio (`global_magnitude_`) influences the target height of these ridges.
  3.  **Organic Movement**: Each ridge has its position and magnitude updated periodically with smoothed, randomized jitter, causing the peaks to drift and shift naturally.
  4.  **Gaussian Profile**: The final shape of the line (`line_profile_`) is generated by summing the influence of all ridges, calculated using a Gaussian function to create smooth, bell-shaped curves.
  5.  **Rendering**: The `render` method now draws the procedurally generated `line_profile_` instead of a raw audio history.

### Step 5: Implementing Multi-Line & The `skyline_buffer` (Completed)

- **Goal**: Draw multiple stacked, generative lines and implement the core occlusion effect.
- **Actions**:
  1.  Change the data model from a single `line_profile_` and `ridges_` vector to a structure that can hold this state for multiple lines (e.g., `std::vector<LineState>`, where `LineState` contains its own profile and ridges).
  2.  In `render()`, create and initialize the `skyline_buffer` (a `std::vector<int>` of size `cols*2`) with the bottom-most pixel row value.
  3.  Modify `draw_line` to become `draw_occluded_line`, adding the `skyline_buffer` as a reference parameter.
  4.  **Inside `draw_occluded_line`**, before setting a bit in the `braille_cells` buffer, add the crucial check: `if (y < skyline_buffer[x])`. If true, set the pixel and then update `skyline_buffer[x] = y`.
  5.  In `render()`, implement the main front-to-back loop. Iterate from `line = 0` to `num_lines - 1`, calculating the `base_y` for each and calling `draw_occluded_line` for each segment of its generated `line_profile_`.
- **Validation**: The application will render multiple stacked, generative waveforms. The nearer (lower) lines will correctly hide the parts of the farther (higher) lines that are behind them. This is the primary visual goal.

### Step 6: Configuration via `when.toml`

- **Goal**: Make the animation's properties configurable.
- **Actions**:
  1.  In the `PleasureAnimation` constructor or `init` method, read settings from the passed `toml::table`.
  2.  Expose the numerous `constexpr` tuning parameters (e.g., `kMagnitudeScale`, `kRidgeSigma`, `kMinRidges`, `kMaxRidges`, `line_spacing`, etc.) as configurable values.
  3.  Replace all hardcoded values from the previous steps with these configuration values.
- **Validation**: Modify the values in `when.toml`. Rerun the application and confirm the animation's behavior and appearance changes accordingly without needing a recompile.
